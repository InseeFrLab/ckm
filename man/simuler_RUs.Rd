% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mesurer_RU.R
\name{simuler_RUs}
\alias{simuler_RUs}
\title{Comparer le risque et l'utilité de plusieurs scénarios en se basant
sur plusieurs simulations}
\usage{
simuler_RUs(
  df,
  cat_vars,
  hrc_vars = NULL,
  parametres,
  confident,
  gv = 50,
  pv = 20,
  n_sim = 10,
  seed = NULL,
  parallel = FALSE,
  max_cores = 4,
  size_workers = NULL
)
}
\arguments{
\item{df}{data.frame or data.table}

\item{cat_vars}{vector of categorical variables but not hierarchical}

\item{hrc_vars}{named list (name = VAR final name, value = VAR current names)}

\item{parametres}{\code{data.frame}}

\item{confident}{\code{integer} Seuil (officiel) de confidentialité}

\item{gv}{\code{integer} seuil désignant les grands comptages}

\item{pv}{\code{integer} seuil désignant les petits comptages}

\item{n_sim}{\code{integer} nombre de simulations}

\item{seed}{\code{integer} numéro de graine aléatoire. Si \code{NULL},
une valeur par défaut est tirée aléatoirement en début de programme.}

\item{parallel}{\code{Boolean} Si \code{TRUE}, les calculs sont parallélisés (avancé)}

\item{max_cores}{\code{integer} Nombre maximum de travaux réalisés en parallèle (avancé)}

\item{size_workers}{\code{integer} Taille en GB allouée à chaque thread lors d'un calcul
en parallèle (avancé).
\code{NULL} par défaut: le programme s'occupe de gérer cette taille par lui même.}
}
\value{
\code{data.frame} de taille \code{n_sim * nrow(parametres)}
}
\description{
Mesurer le risque et l'utilité à partir d'un tableau,
sur un ensemble de jeux de clés générés aléatoirement et
sur plusieurs jeux de paramètres.
}
\section{La graine aléatoire}{


La graine aléatoire permet d'assurer la reproductibilité du travail. De plus,
afin d'assurer que les résultats soient bien comparables entre les scénarios,
le programme assure que les mêmes jeux de clés sont utilisés. C'est pourquoi,
en l'absence de graine aléatoire renseignée, le programme se charge
d'en tirer une aléatoirement.
}

\section{La parallélisation}{


Paralléliser son calcul permet d'utiliser une puissance de calculs plus importante
pour réaliser les simulations. Cette technique permet en général un gain de temps
appréciable.

Ici, ce sont les `n_sim` simulations qui sont distribuées sur plusieurs coeurs.
La parallélisation sera donc intéressante quand le temps pour réaliser ces simulations
pour un scénario donné est supérieur au temps de créations des travaux.

Enfin, il faut pouvoir s'assurer qu'on dispose des ressources suffisantes pour lancer
le calcul. On pourra utiliser  [parallel::detectCores()] ou
[future::availableCores()] pour connaître le nombre
de coeurs disponibles sur votre machine, l'idée étant de ne pas saturer ces ressources.

Si le nombre de travaux en parallèles demandé est supérieur aux ressources,
le programme choisi un nombre égal à `future::availableCores() - 1`.
}

\examples{
parametres <- construire_table_parametres(c(10,15), c(10,20), js = 5)
res_sim_RUs <- simuler_RUs(
  df = dtest,
  cat_vars = c("REG", "DIPLOME", "SEXE", "AGE"),
  parametres = parametres,
  confident = 10,
  n_sim = 10,
  seed = 1234
)
}
