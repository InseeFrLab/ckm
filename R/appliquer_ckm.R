#' Apply Cell Key Method to a contingency table
#'
#' This function applies the Cell Key Method perturbation to a contingency table
#' generated by `tabulate_cnt_micro_data`, using specified deviation and variance parameters.
#'
#' @param tab_data Object returned by `tabulate_cnt_micro_data` (data.frame or list)
#' @param cnt_var Character. Name of the count variable (default: "nb_obs")
#' @param ck_var Character. Name of the cell key variable (must be decimal between 0-1)
#' @inheritParams create_transition_matrix
#' @inheritParams assess_risk
#' @param ... Additional parameters passed to transition matrix creation
#'
#' @return List containing:
#' - tab: Perturbed table (tibble)
#' - risque: Risk measures (NULL if empirical frequencies not provided)
#' - utilite: Utility measures (MAD, RMAD, Hellinger distance)
#' - ptab: Transition matrix object
#'
#' @export
#' @examples
#' \dontrun{
#' data("dtest")
#' set.seed(8245)
#' dtest_avec_cles <- build_individual_keys(dtest)
#'
#' tab_avant <- tabulate_cnt_micro_data(
#'   df = dtest_avec_cles,
#'   cat_vars = c("DIPLOME", "SEXE", "AGE"),
#'   hrc_vars = list(GEO = c("REG", "DEP")),
#'   marge_label = "Total",
#'   freq_empiriq = TRUE
#' )
#'
#' res_ckm <- apply_ckm(tab_avant, D = 5, V = 2)
#' str(res_ckm, max.level = 2)
#'
#' # With a hierarchical structure
#' tab_avant2 <- tabulate_cnt_micro_data(
#'   df = dtest_avec_cles |> mutate(NUM = 12),
#'   cat_vars = c("DIPLOME", "SEXE", "AGE"),
#'   hrc_vars = list(GEO = c("REG", "DEP")),
#'   num_var = "NUM",
#'   marge_label = "Total",
#'   freq_empiriq = TRUE #pour pouvoir mesurer le risque
#' )
#'
#' res_ckm2 <- apply_ckm(tab_avant2, cnt_var = "num_tot", D = 5, V = 2)
#' head(res_ckm2$tab)
#' }
#' @importFrom data.table as.data.table setkeyv foverlaps .N .SD :=
#' @importFrom dplyr mutate rename_with select
#' @importFrom tibble as_tibble tibble
#' @importFrom assertthat assert_that
apply_ckm <- function(
  tab_data,
  cnt_var = "nb_obs",
  ck_var = "ckey",
  D,
  V,
  js = 0,
  I = NULL,
  J = NULL,
  ...
) {

  # Check input type and extract data
  if (!is.data.frame(tab_data)) {
    if (is.list(tab_data) & length(tab_data) == 2 & all(names(tab_data) %in% c("tab", "freq"))) {
      dt_data <- data.table::as.data.table(tab_data$tab)
      p_hat <- tab_data$freq
    } else {
      stop("The argument tab_data must be a data.frame/tibble or a list of two data.frames/tibbles")
    }
  } else {
    dt_data <- as.data.table(tab_data)
    p_hat <- NULL
  }
  # Check if the count variable exists
  assertthat::assert_that(
    cnt_var %in% names(dt_data),
    msg = "The count variable specified in the `cnt_var` argument does not exist in the provided dataset."
  )
  # Check if the count variable is integer
  assertthat::assert_that(
    is.integer(dt_data[[cnt_var]]),
    msg = "The count variable specified in the `cnt_var` argument must be integer"
  )
  # Check if the count variable is non-negative
  assertthat::assert_that(
    all(dt_data[[cnt_var]] >= 0),
    msg = "The count variable specified in the `cnt_var` argument must be non-negative."
  )

  # Check if the cell key variable exists and is in the range [0, 1]
  assertthat::assert_that(
    ck_var %in% names(dt_data),
    msg = "The cell key variable specified in the `ck_var` argument does not exist in the provided dataset."
  )
  # Check if the cell key variable is numeric
  assertthat::assert_that(
    is.numeric(dt_data[[ck_var]]),
    msg = "The cell key variable specified in the `ck_var` argument must be numeric."
  )
  # Check if the cell key variable is in the range [0, 1]
  assertthat::assert_that(
    min(dt_data[[ck_var]]) >= 0 & max(dt_data[[ck_var]]) <= 1,
    msg = "The cell key must be a value between 0 and 1"
  )

  # Build the perturbation table
  args_add <- c(...)
  args_trans <- if (length(args_add) == 0) as.list(c(D = D, V = V, js = js)) else as.list(c(D = D, V = V, js = js, args_add))

  mat_trans <- do.call("create_transition_matrix", args_trans)
  tab_pert <- prepare_perturbation_table(mat_trans)
  max_i <- max(tab_pert$i)

  dt_data[, `:=`(i = ifelse(get(cnt_var) <= max_i, get(cnt_var), max_i))]
  # cell_key = rkeys_tot %% 1, # retrieve the decimal part of the sum of keys
  # for convenience for merging
  # transition probabilities for values > max_i are identical to i = max_i

  dt_data[, ck_end := get(ck_var)]
  data.table::setkeyv(dt_data, cols = c("i", ck_var, "ck_end"))

  # interval join
  cnt_var_ckm <- paste0(cnt_var, "_ckm")
  res <- data.table::foverlaps(dt_data, tab_pert, mult = "all") |>
    dplyr::mutate(res_ckm = get(cnt_var) + v) |>
    dplyr::rename_with(~cnt_var_ckm, res_ckm)

  # Risk measures if empirical frequencies are provided in tab_data
  if (!is.null(p_hat) & !is.null(I) & !is.null(J)) {
    risque <- assess_risk(mat_trans, p_hat, I, J)
  } else {
    risque <- NULL
  }

  # Utility measures
  utilite <- tibble::tibble(
    MAD = mean_absolute_deviation(res[[cnt_var]], res[[cnt_var_ckm]]),
    RMAD = mean_relative_absolute_deviation(res[[cnt_var]], res[[cnt_var_ckm]]),
    HD = distance_hellinger(res[[cnt_var]], res[[cnt_var_ckm]])
  )

  # Consistency check
  if (
    nrow(res) == nrow(dt_data) &
    nrow(res[get(ck_var) > p_int_ub | get(ck_var) < p_int_lb, ]) == 0
  ) {

    return(
      list(
        tab = res |>
          as.data.frame() |>
          tibble::as_tibble() |>
          dplyr::select(-ck_end, -i, -v, -p_int_lb, -p_int_ub, -{{ ck_var }}),
        risque = risque,
        utilite = utilite,
        ptab = mat_trans
      )
    )

  } else {
    warning("The result of the join is inconsistent. Please check your result.")
    return(
      list(
        tab = res,
        ptab = mat_trans
      )
    )
  }
}
